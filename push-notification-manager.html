<!--
  Copyright 2015 Google Inc. All Rights Reserved.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->
<link rel="import" href="../polymer/polymer.html">

<script>
  (function() {
    // TODO: Doesn't work for IE or Safari, and the usual
    // document.getElementsByTagName('script') workaround seems to be broken by
    // HTML imports. Not important for now as neither of those browsers support
    // service worker yet.
    var currentScript = document.currentScript.baseURI;

    var SCOPE_BASE = new URL('./$$push-notification-manager$$/', currentScript).href;
    var WORKER_URL = new URL('./service-worker.js', currentScript).href;

    var SUPPORTED = 'serviceWorker' in navigator &&
        'PushManager' in window  &&
        'Notification' in window;

    /**
     * `<push-notification-manager>` sets up a
     * [push messaging](http://updates.html5rocks.com/2015/03/push-notificatons-on-the-open-web)
     * subscription and allows you to define what happens when a push message is
     * received.
     *
     * The element can be placed anywhere.
     * 
     * The data for how a notification should be displayed can come from one of
     * three places.
     *
     * Firstly, you can specify a URL from which to fetch the message data.
     * ```
     * <push-notification-manager
     *   message-url="notification-data.json">
     * </push-notification-manager>
     * ```
     *
     * The second way is to send the message data in the body of
     * the push message from your server. In this case you do not need to
     * configure anything in your page:
     * ```
     * <push-notification-manager></push-notification-manager>
     * ```
     * **Note that this method is not currently supported by any browser**. It
     * is, however, defined in the
     * [draft W3C specification](http://w3c.github.io/push-api/#the-push-event)
     * and this element should use that data when it is implemented in the
     * future.
     *
     * If a message-url is provided then the message body will be ignored in
     * favor of the first method.
     *
     * Thirdly, you can manually define the attributes on the element:
     * ```
     * <push-notification-manager
     *   title="Application updated"
     *   message="The application was updated in the background"
     *   icon-url="icon.png"
     *   click-url="notification.html">
     * </push-notification-manager>
     * ```
     * These values will also be used as defaults if one of the other methods
     * does not provide a value for that property.
     */
    Polymer({
      is: 'push-notification-manager',

      properties: {

        /**
         * Indicates whether the Push and Notification APIs are supported by
         * this browser.
         */
        supported: {
          readOnly: true,
          type: Boolean,
          value: SUPPORTED
        },

        /**
         * The details of the current push subscription, if any.
         */
        subscription: {
          readOnly: true,
          type: PushSubscription,
          notify: true,
          value: ''
        },

        /**
         * Indicates the status of the element. If true, push messages will be
         * received.
         */
        enabled: {
          readOnly: true,
          type: Boolean,
          notify: true,
          value: false
        },

        /**
         * An optional label for the notifications that will be generated by
         * this element. Notifications with the same tag will overwrite one
         * another, so that only one will be shown at once.
         */
        tag: String,

        /**
         * A URL from which message information can be retrieved.
         *
         * When a push event happens that does not contain a message body this
         * URL will be fetched. The URL is expected to be for a JSON document in
         * the format:
         * ```
         * {
         *   "title": "The title for the notification",
         *   "body": "The message to display in the notification",
         *   "url": "The URL to display when the notification is clicked",
         *   "icon": "The URL of an icon to display with the notification"
         * }
         * ```
         */
        messageUrl: String,

        /**
         * A default notification title.
         */
        title: String,

        /**
         * A default notification message.
         */
        message: String,

        /**
         * A default icon for notifications.
         */
        iconUrl: String,

        /**
         * A default URL to display when a notification is clicked.
         */
        clickUrl: {
          type: String,
          value: document.location.href
        }
      },

      /**
       * Fired when a notification is clicked that had the current page as the
       * click URL.
       *
       * @event push-notification-manager-click
       * @detail {Object} The push message data used to create the notification
       */

      /**
       * Fired when a push message is received but no notification is shown.
       * This happens when the click URL is for this page and the page is
       * visible to the user on the screen.
       *
       * @event push-notification-manager-push
       * @detail {Object} The push message data that was received
       */

      /**
       * Fired when an error occurs while enabling or disabling notifications
       *
       * @event push-notification-manager-error
       * @detail {String} The error message
       */

      /** @return {String} the scope to use for the service worker */
      _getScope: function() {
        return SCOPE_BASE + (this.tag || '' );
      },

      /**
       * Returns a promise which will resolve to the registration object
       * associated with our current service worker.
       *
       * @return {Promise<ServiceWorkerRegistration>}
       */
      _getRegistration: function() {
        return navigator.serviceWorker.getRegistration(this._getScope());
      },

      /**
       * Returns a promise that will resolve when the given registration becomes
       * active.
       *
       * @param registration {ServiceWorkerRegistration}
       * @return {Promise<undefined>}
       */
      _registrationReady: function(registration) {
        if (registration.active) {
          return Promise.resolve();
        }

        var serviceWorker = registration.installing || registration.waiting;

        return new Promise(function(resolve, reject) {
          // Because the Promise function is called on next tick there is a
          // small chance that the worker became active already.
          if (serviceWorker.state === 'activated') {
            resolve();
          }
          var listener = function(event) {
            if (serviceWorker.state === 'activated') {
              resolve();
            } else if (serviceWorker.state === 'redundant') {
              reject(new Error('Worker became redundant'));
            } else {
              return;
            }
            serviceWorker.removeEventListener('statechange', listener);
          }
          serviceWorker.addEventListener('statechange', listener);
        }); 
      },

      /**
       * Resolves a URL that is relative to the page to an absolute URL
       *
       * @param url {String} a relative URL
       * @return {String} the equivalent absolute URL
       */
      _absUrl: function(url) {
        if (typeof(url) === 'string') {
          return new URL(url, document.location).href;
        }
      },

      /**
       * Event handler for the `message` event.
       *
       * @param event {MessageEvent}
       */
      _messageHandler: function(event) {
        if (event.data && event.data.source === this._getScope()) {
          switch(event.data.type) {
          case 'push':
            this.fire('push-notification-manager-push', event.data);
            break;
          case 'click':
            this.fire('push-notification-manager-click', event.data);
            break;
          }
        }
      },

      /**
       * Takes an options object and creates a stable JSON serialization of it.
       * This naive algorithm will only work if the object contains only
       * non-nested properties.
       *
       * @param options {Object.<String, ?(String|Number|Boolean)>}
       * @return String
       */
      _serializeOptions: function(options) {
        var props = Object.keys(options);
        props.sort();
        var parts = props.filter(function(propName) {
          return !!options[propName];
        }).map(function(propName) {
          return JSON.stringify(propName) + ':' + JSON.stringify(options[propName]);
        });
        return '{' + parts.join(',') + '}';
      },

      /**
       * Request push messaging to be enabled.
       *
       * @return {Promise<undefined>}
       */
      enable: function() {
        if (!this.supported) {
          return this.fire('push-notification-manager-error', 'Your browser does not support push notifications');
        }

        return (new Promise(Notification.requestPermission)).then(function(permission) {
          if (permission === 'denied') {
            return Promise.reject(new Error('Cannot enable notifications: Permission denied'));
          } else if (permission !== 'granted') {
            return Promise.reject(new Error('Cannot enable notifications: Permission was not granted'));
          }

          var options = this._serializeOptions({
            tag: this.tag,
            messageUrl: this._absUrl(this.messageUrl),
            title: this.title,
            message: this.message,
            iconUrl: this._absUrl(this.iconUrl),
            clickUrl: this._absUrl(this.clickUrl)
          });

          var workerScript = WORKER_URL + '?' + options;

          return navigator.serviceWorker.register(workerScript, {scope: this._getScope()}).then(function(registration) {
            return this._registrationReady(registration).then(function() {
              return registration.pushManager.subscribe();
            });
          }.bind(this)).then(function(subscription) {
            this._setSubscription(subscription);
            this._setEnabled(true);
          }.bind(this));
        }.bind(this)).catch(function(error) {
          this.fire('push-notification-manager-error', error.message || error);
        }.bind(this));
      },

      /**
       * Request push messaging to be disabled.
       *
       * @return {Promise<undefined>}
       */
      disable: function() {
        if (this.supported) {
          this._getRegistration().then(function(registration) {
            if (!registration) {
              return;
            }
            return registration.pushManager.getSubscription().then(function(subscription) {
              if (subscription) {
                return subscription.unsubscribe();
              }
            }).then(function() {
              return registration.unregister();
            }).then(function() {
              this._setSubscription();
              this._setEnabled(false);
            }.bind(this)).catch(function(error) {
              this.fire('push-notification-manager-error', error.message || error);
            }.bind(this));
          }.bind(this));
        }
      },

      ready: function() {
        if (this.supported) {
          var handler = this._messageHandler.bind(this);
          // NOTE: We add the event listener twice because the specced and
          // implemented behaviors do not match. In Chrome 42, messages are
          // received on window. In the current spec they are supposed to be
          // received on navigator.serviceWorker.
          // TODO: Remove the non-spec code in the future.
          window.addEventListener('message', handler);
          navigator.serviceWorker.addEventListener('message', handler);

          this._getRegistration().then(function(registration) {
            if (!registration) {
              return;
            }
            return registration.pushManager.getSubscription().then(function(subscription) {
              this._setSubscription(subscription);
            }.bind(this))
          }.bind(this));
        }
      }    
    });
  })();
</script>

